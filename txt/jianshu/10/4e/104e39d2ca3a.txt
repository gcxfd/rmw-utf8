Python3.X内置函数
Python解释器内置了许多功能和类型,总是可用的。他们是按字母顺序列在这里。
abs(
返回一个数的绝对值。参数可能是整数或浮点数。如果参数是一个复数,返回它的大小。
all(
返回 True
如果所有的元素iterable真(或者如果iterable为空)。等价于:
defall(iterable):forelementiniterable:ifnotelement:returnFalsereturnTrue
any(
返回 True
如果任何元素的iterable是正确的。如果iterable为空,返回 False
。等价于:
defany(iterable):forelementiniterable:ifelement:returnTruereturnFalse
ascii(
作为 repr()
返回一个字符串,包含一个可打印的表示一个对象,但是逃避返回的字符串中的非ascii字符 repr()
使用 \x
, \u
或 \U
逃跑了。这生成一个字符串返回的相似 repr()
在Python中2。
bin(
将一个整数转换成一个二进制字符串。结果是一个有效的Python表达式。如果x是Python int
对象,它必须定义一个
方法返回一个整数。
返回一个布尔值,即之一 True
或 False
。x是使用标准的转换 真理的检验程序。如果x是虚假或省略,这个回报 False
;否则它返回 True
。的 bool
类的一个子类 int
(见 数值类型,int、浮点数、复杂)。它不能再进一步。它唯一的实例 False
和 True
(见 布尔值).
([
返回一个新的数组的字节数。的 bytearray
类是一个可变的序列的整数范围0 < = x < 256。它具有可变序列的最常见的方法,描述了 可变序列类型,以及大多数的方法 bytes
类型,看 字节和中Bytearray操作.
可选的源参数可以用来初始化数组在几个不同的方式:
如果它是一个字符串,你还必须给编码(和可选地,错误)参数; bytearray()
然后将字符串转换成字节使用 str.encode()
.
如果它是一个整数,该数组将与空字节大小和将被初始化。
如果它是一个对象符合缓冲界面,一个只读缓冲区将被用来初始化对象的字节数组。
如果它是一个iterable,它必须是一个整数的iterable范围 0 <= x < 256
,这是作为数组的初始内容。
没有一个论点,创建了一个数组大小为0。
另请参阅 二进制序列类型——字节中bytearray,memoryview和 中Bytearray对象.
返回一个新的“字节”对象,这是一个不可变的序列的整数范围 0 <= x < 256
. bytes
不可变的版本吗 bytearray
接触非变异——它有相同的刺突的方法和相同的索引和切片的行为。
因此,构造函数参数解释为 bytearray()
.
字节对象也可以创建文字,明白了 文本字符串和字节.
另请参阅 二进制序列类型——字节中bytearray,memoryview, 字节, 字节和中Bytearray操作.
callable(
返回 True
如果对象参数出现可调用的, False
如果不是。如果返回true,它仍然是有可能的,调用失败,但是如果它是假的,调用对象永远不会成功。注意,类是可调用(调用一个类返回一个新实例);如果他们的类有一个可调用的实例
方法。
在新的3.2版本:这个函数首先移除在Python 3.0,然后带回在Python 3.2。
chr(
返回的字符串代表一个字符的Unicode代码点整我。例如, chr(97)
返回的字符串 'a'
,而 chr(8364)
返回的字符串 '€'
。这是的倒数 ord()
.
参数的有效范围从0到1114111年(0 x10ffff基地16)。 ValueError
如果我不在这个范围将提高。
classmethod(
函数返回一个类方法。
一个类方法接收类隐式的第一个参数,就像一个实例方法接收实例。声明一个类方法,使用这个成语:
classC:@classmethoddeff(cls,arg1,arg2,...):...
的 @classmethod
表单是一个函数 装饰——看到函数定义的描述 函数定义获取详细信息。
它可以被称为类(如 C.f()
(比如)或在一个实例 C().f()
)。除了它的类实例被忽略。如果一个类派生类的方法被调用时,派生类对象作为隐含第一个参数传递。
类方法是不同的比c++或Java静态方法。如果你想要这些,明白了 staticmethod()
在这一节中。
关于类方法的更多信息,请参考文档标准类型层次结构 标准的类型层次结构.
compile(源、文件名模式,旗帜= 0,dont_inherit = False,
编译成一个源代码或AST对象。对象可以执行的代码 exec()
或 eval()
。来源可以是一个普通的字符串,一个字节的字符串,或一个AST对象。指的是 ast
模块的文档信息如何使用AST对象。
文件名参数应该给文件的代码阅读,通过一些可识别的值如果不是从文件读('<string>'
是常用的)。
模式参数指定什么样的代码必须被编译,就可以 'exec'
如果源由一系列的语句, 'eval'
如果它包含一个表达式,或 'single'
如果它包括一个交互式的声明(在后一种情况下,表达式语句,评估以外的东西 None
将打印)。
未来的可选参数标志和dont_inherit控制语句(见
。如果旗帜参数是dont_inherit并不是(或为零),那么未来语句指定的标志使用参数除了那些将使用。如果dont_inherit是一个非零的整数,那么旗帜的论点是,未来在调用编译语句实际上被忽略。
未来语句指定比特可按位或共同指定多个语句。所需的设置指定给定的特性可以发现 compiler_flag
属性 _Feature
实例的
模块。
参数优化指定编译器的优化级别;默认值的 -1
选择的翻译的优化级别 -O
选项。明确的水平 0
(没有优化;
是正确的), 1
(断言移除,
是假的)或 2
(删除文档字符串)。
这个函数了 SyntaxError
如果编译源无效 ValueError
如果源包含空字节。
如果你想Python代码解析成AST表示,看到的 ast.parse()
.
请注意
当编译一个字符串与多行代码 'single'
或 'eval'
模式下,输入必须终止由至少一个换行符。这是为了方便检测不完整的和完整的语句 code
模块。
3.2版本的变化:允许使用Windows和Mac换行。也投入 'exec'
模式没有以换行符结束了。增加了优化参数。
3.5版本的变化:在此之前, TypeError
长大当空字节中遇到的来源。
返回一个与真实值+复数图像放大* 1 j或字符串或数字转换为复数。如果第一个参数是一个字符串,它将被视为复数和函数必须调用第二个参数。第二个参数不能是一个字符串。每个参数可以是任何数字类型(包括复杂)。如果省略图像放大,它默认为零和构造函数作为一个数字转换 int
和 float
。如果两个参数省略,回报 0j
.
请注意
当转换从一个字符串,字符串必须不包含空格在中央 +
或 -
操作符。例如, complex('1+2j')
是可以的,但 complex('1 + 2j')
提出了 ValueError
.
描述的复杂类型 数值类型,int、浮点数、复杂.
3.6版本的变化:分组代码中位数与下划线文字是被允许的。
delattr(对象,
这是一个相对的 setattr()
。的参数是一个对象和一个字符串。字符串必须是一个对象的属性的名称。该函数删除指定的属性,提供了对象允许它。例如, delattr(x, 'foobar')
相当于 del x.foobar
.
(映射,
(iterable,
创建一个新字典。的 dict
对象字典类。看到 dict
和 映射类型——dict类型关于这个类的文档。
对于其他容器内置 list
, set
, tuple
类,以及 collections
模块。
dir([
没有参数,返回当前局部范围的名单。与论证,试图返回有效的属性的对象的列表。
如果对象有一个名为的方法
,这个方法将被称为,必须返回属性的列表。这样就可以实现一个自定义的对象
或
功能定制 dir()
报告它们的属性。
如果对象没有提供
,功能尽量从对象的收集信息
属性,如果定义,并从其类型对象。结果不一定是完整的列表,和对象有一个自定义时可能不准确
.
默认的 dir()
机制不同的行为与不同类型的对象,因为它试图产生最相关的,而不是完整的信息:
如果对象是一个模块对象,列表包含模块的属性的名称。
如果对象是一个类型或类对象,列表包含它的属性的名称和属性的递归的基地。
否则,该列表包含该对象的属性的名称、类的属性的名称和属性的递归的类的基类。
生成的列表按字母顺序排序。例如:
importstruct>>> dir()# show the names in the module namespace['_(self):... return['area','perimeter','location']>>> s=Shape()>>> dir(s)['area', 'location', 'perimeter']
请注意
因为 dir()
主要是提供方便使用交互式提示符,它试图提供一组有趣的名字超过它试图提供一个严格或定义一致的组名称,并在发布其详细的行为可能会改变。例如,元类属性不是在结果列表参数是一个类。
divmod(一个,
取两个(非复杂)的数字作为参数并返回一个数字组成的商和余数当使用整数的除法。与混合操作数类型,二进制算术运算符的规则适用。为整数,结果是一样的 (a // b, a % b)
。浮点数结果 (q, a % b)
通常,问math.floor(a / b)
但可能小于1。在任何情况下 q * b + a % b
非常接近,如果 a % b
非零和b一样的标志,然后呢 0 <= abs(a % b) < abs(b)
.
enumerate(iterable,
返回一个枚举对象。iterable必须是一个序列,一个 迭代器或其他对象支持迭代。的
返回的迭代器的方法 enumerate()
返回一个元组,其中包含一个计数(从开始默认为0),并获得的值遍历iterable。
seasons=['Spring','Summer','Fall','Winter']>>> list(enumerate(seasons))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]>>> list(enumerate(seasons,start=1))[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
等价于:
defenumerate(sequence,start=0):n=startforeleminsequence:yieldn,elemn+=1
eval(表达式,全局变量=没有
参数是一个字符串,可选的全局和当地人。如果提供,全局变量必须是一个字典。如果提供,当地人可以是任何对象的映射。
解析表达式参数和评估作为一个Python表达式(技术上来说,一个条件列表)使用全局和本地词典作为全球和本地名称空间。如果存在全局字典,缺乏“
模块和限制环境传播。如果省略当地人字典它默认为全局字典。如果字典都省略了,表达式是在环境中执行 eval()
被称为。返回值是计算表达式的结果。语法错误报告为例外。例子:
x=1>>> eval('x+1')2
这个函数也可以用来执行任意代码(比如由对象 compile()
)。在这种情况下,传递一个代码对象,而不是一个字符串。如果代码对象编译了 'exec'
作为模式的参数, eval()
的返回值 None
.
提示:支持动态执行语句 exec()
函数。的 globals()
和 locals()
函数返回当前全球和本地词典,分别,这可能是有用的在使用的 eval()
或 exec()
.
看到 ast.literal_eval()
为一个函数,可以安全评估与表达式只包含字符串字面值。
exec(
这个函数支持Python代码的动态执行。对象必须是一个字符串或对象代码。如果它是一个字符串,字符串解析为一套然后执行Python语句(除非出现语法错误)。[1]如果它是一个代码的对象,它只是执行。在所有情况下,预计将是有效执行的代码文件输入(见参考手册中的部分“输入文件”)。请注意, return
和 yield
语句之外不得使用函数定义的上下文中甚至代码传递到 exec()
函数。返回值是 None
.
在所有情况下,如果省略可选的部分,执行代码在当前的范围。如果全局变量,它必须是一个字典,将用于全球和本地变量。如果全局变量和当地人,他们用于全球和本地变量,分别。如果提供,当地人可以是任何对象的映射。记住,在模块级别,全局和当地人是相同的字典。如果执行两个独立的对象作为全局变量和当地居民,将执行的代码,就好像它是嵌入在一个类的定义。
如果全局字典不包含一个值的关键
,内置的词典模块 builtins
插入钥匙。这样你可以控制内置命令可以执行代码插入自己的
字典到全局变量传递之前 exec()
.
请注意
内置的功能 globals()
和 locals()
返回当前全球和本地词典,分别,这可能是有用的在第二和第三个参数使用 exec()
.
请注意
默认的当地人作为函数的描述 locals()
下图:修改默认当地人字典不应该尝试。通过显式的当地人字典如果你需要看后的代码对当地人的影响函数 exec()
的回报。
filter(函数,
从这些元素的iterable构造迭代器函数返回true。iterable可以是一个序列,一个容器支持迭代,迭代器。如果函数是 None
,恒等函数假设,即所有元素的iterable假被删除。
请注意, filter(function, iterable)
相当于生成器表达式 (item for item in iterable if function(item))
如果函数不 None
和 (item for item in iterable if item)
如果函数是 None
.
看到 itertools.filterfalse()
iterable互补函数,它返回元素的函数返回false。
返回一个浮点数由一个数字或字符串x。
如果参数是一个字符串,它应该包含一个十进制数,选择之前签署,有选择地嵌入空格。可选的迹象 '+'
或 '-'
; '+'
对产生的价值没有影响。参数也可以是一个字符串代表南(不是一个数字),或积极或消极的无穷。更准确地说,输入后必须符合以下语法前导和尾随空白字符删除:
签名::= " + " |“-”无穷::=“∞”|“正”南::= "南"numeric_value::=floatnumber
| infinity
| nan
numeric_string::=(sign
] numeric_value
在这里 floatnumber
Python浮点文字的形式,描述在吗 浮点文字。情况并不明显,所以,例如,“正”、“正”、“∞”和“∞”都是可接受的拼写为正无穷。
否则,如果参数是一个整数或浮点数,浮点数和相同的值(在Python的浮点精度)返回。如果参数是一个Python浮动的范围外,一个 OverflowError
将会提高。
对于一般的Python对象 x
, float(x)
代表 x.
.
如果没有给出参数, 0.0
返回。
例子:
float('+1.23')1.23>>> float(' -12345\n')-12345.0>>> float('1e-003')0.001>>> float('+1E6')1000000.0>>> float('-Infinity')-inf
浮子式中描述 数值类型,int、浮点数、复杂.
3.6版本的变化:分组代码中位数与下划线文字是被允许的。
format(
将一个值转换为一个表示“格式化”,由format_spec控制。解释format_spec取决于值的类型参数,然而有一个标准格式使用语法,最内置类型: 格式规范迷你语言.
默认format_spec是一个空字符串通常给调用相同的效果 str(value)
.
调用 format(value, format_spec)
是翻译 type(value).
它绕过了实例的字典当寻找价值的
方法。一个 TypeError
如果搜索的方法达到异常 object
format_spec非空,或者如果format_spec或返回值不是字符串。
3.4版本的变化: object().
提出了 TypeError
如果format_spec不是一个空字符串。
返回一个新的 frozenset
对象,可选元素取自iterable。 frozenset
是一个内置的类。看到 frozenset
和 类型——集合,frozenset关于这个类的文档。
对于其他容器内置 set
, list
, tuple
, dict
类,以及 collections
模块。
getattr(对象,
返回指定属性的值的对象。名称必须是一个字符串。如果字符串是对象的一个属性的名字,结果是,属性的值。例如, getattr(x, 'foobar')
相当于 x.foobar
。如果指定的属性不存在,返回默认如果提供,否则AttributeError
是提高。
globals()
返回一个代表当前全局符号表字典。这总是当前模块的字典(在一个函数或方法,这是定义的模块,不叫做的模块)。
hasattr(对象,
的参数是一个对象和一个字符串。结果是 True
如果字符串是对象的一个属性的名字, False
如果不是。(这是通过调用实现的 getattr(object, name)
看到它是否提出了一个 AttributeError
不信)。
hash(
返回对象的散列值(如果它有一个)。散列值是整数。他们是用来快速比较在字典查找字典键。数值比较平等有相同的散列值(即使他们是不同类型的,1和1.0)一样。
请注意
与自定义对象的
方法,注意, hash()
返回值截断基于主机的位宽。看到
获取详细信息。
help([
调用内置的帮助系统。(这个函数是用于交互式使用。)如果没有参数,翻译上的互动帮助系统启动控制台。如果参数是一个字符串,字符串查找模块的名称,函数,类,方法,关键字,或文档的主题,一个帮助页面打印在控制台上。如果参数是任何其他类型的对象,生成一个对象上的帮助页面。
这个函数添加到内置的名称空间 site
模块。
3.4版本的变化:更改 pydoc
和 inspect
意味着报道签名可调用现在更全面和一致的。
把一个整数转换成小写的十六进制字符串前缀“0 x”,例如:
>>> hex(255)
'0xff'
>>> hex(-42)
'-0x2a'
如果x是Python int
对象,它必须定义一个
另请参阅 int()
将十六进制字符串转换为一个整数使用16的基地。
请注意
获得一个浮动的十六进制字符串表示,使用 float.hex()
方法。
id(
返回一个对象的“身份”。这是一个整数保证独特和常数这个对象在它的生命周期。两个对象重叠寿命可能有相同的 id()
价值。
这是在内存中对象的地址。
])
如果提示存在争论,末尾写到标准输出没有换行符。从输入函数然后读取一行,将其转换为一个字符串(剥离后换行),并返回。当EOF阅读, EOFError
是提高。例子:
>>>
>>> s=input('--> ')
--> Monty Python's Flying Circus
>>> s"Monty Python's Flying Circus"
如果 readline
模块被加载 input()
将使用它来提供详尽的行编辑和历史特征。
)
返回一个整数对象由一个数字或字符串x,或者退货 0
如果没有参数。如果x是一个数字,回报 x.
。对于浮点数,这对截断零。
如果x不是很多或者基地,那么x必须是一个字符串, bytes
,或 bytearray
实例代表一个 整数字面在基数基础。可选地,可以之前的文字 +
或 -
(没有之间的空间)和周围的空白。base-n文字由数字0到n - 1, a
来 z(或 A来 Z10 - 35)值。默认的基础是10。允许的值是0,转动。以2为底,8,-16文字可以选择前缀 0b/0B, 0o/0O,或 0x/0X在代码中,与整数文字。基地0意味着代码字面解释一样,所以实际的基础是2,8,10或16,所以 int('010', 0)是不合法的,int('010')是,以及 int('010', 8).
描述的整数类型 数值类型,int、浮点数、复杂.
3.4版本的变化:如果基础不是的一个实例 int
和基础对象 base.
方法,调用方法获得一个整数的基地。使用以前的版本 base.
而不是 base.
.
3.6版本的变化:分组代码中位数与下划线文字是被允许的。
isinstance(对象,
返回true,如果参数是对象的一个实例classinfo论点,或(直接、间接或 虚拟)子类。如果对象不是一个给定类型的对象,函数始终返回false。如果classinfo tuple类型的对象(或递归,其他元组),返回true,如果对象是任何类型的一个实例。如果classinfo不是一个类型或元组的类型和元组等 TypeError
例外。
issubclass(类,
返回true,如果类(直接、间接或一个子类 虚拟classinfo)。一个类被认为是自身的一个子类。classinfo可能是一个类对象的元组,在这种情况下,每一个进入classinfo将检查。在任何其他情况下, TypeError
例外。
iter(
返回一个 迭代器对象。第一个参数是解释不同的根据第二个参数的存在。没有第二个参数,对象必须是一组对象支持迭代协议(
方法),也必须支持的协议序列(
方法用整数参数开始 0
)。如果它不支持的协议, TypeError
是提高。哨兵,如果第二个参数,那么对象必须是一个可调用对象。在这种情况下,创建的迭代器将为每个调用不带参数调用对象
方法;如果返回的值等于哨兵, StopIteration
将提高,否则将返回值。
另请参阅 迭代器类型.
第二种的一个有用的应用程序 iter()
是读取行一个文件直到到达一定行。下面的例子将读取一个文件,直到 readline()
方法返回一个空字符串:
withopen('mydata.txt')asfp:forlineiniter(fp.readline,''):process_line(line)
len(
返回对象的长度(项目)的数量。参数可以是一个序列(如一个字符串,字节,tuple,列表,或范围)或一组(如字典、集,或冷冻集)。
而不是一个函数, list
实际上是一个可变的序列类型,记录在吗 列表和 序列类型——列表、元组、范围.
locals()
字典更新并返回一个表示当前本地符号表。自由变量返回 locals()
当它被称为功能块,但不是在课堂上。
请注意
这本字典的内容不应被修改;变化可能不会影响当地和自由变量的值所使用的翻译。
map(函数,iterable,* ...*)
返回一个迭代器函数适用于每件iterable,产生结果。如果额外iterable参数传递,函数必须采取许多参数和应用于项目并行iterable。与多个iterable,迭代器停止当最短的iterable耗尽。情况下,函数已经安排输入参数元组,明白了itertools.starmap().
max(iterable,*
max
(__arg1、最长,** args
返回iterable或最大的项目中最大的两个或两个以上的参数。
如果提供了一个位置参数,它应该是一个 iterable。最大的项目返回iterable。如果提供两个或两个以上的位置参数,返回最大的位置参数。
有两个可选keyword-only参数。关键参数指定一个参数排序函数用于 list.sort()
。默认参数指定一个对象返回,如果提供iterable是空的。如果iterable为空,���认不提供, ValueError
是提高。
如果多个项目最大,函数返回第一个。这是符合其他sort-stability保留等工具 sorted(iterable, key=keyfunc, reverse=True)[0]
和 heapq.nlargest(1, iterable, key=keyfunc)
.
在新的3.4版本:默认keyword-only论点。
memoryview(
返回一个“内存视图对象创建从给定的参数。看到 内存视图为更多的信息。
min(iterable,*
min(__arg1、最长,** args
返回最小项iterable或最小的两个或两个以上的参数。
如果提供了一个位置参数,它应该是一个 iterable。最小的项目返回iterable。如果提供两个或两个以上的位置参数,返回最小的位置参数。
有两个可选keyword-only参数。关键参数指定一个参数排序函数用于 list.sort()
。默认参数指定一个对象返回,如果提供iterable是空的。如果iterable为空,���认不提供, ValueError
是提高。
如果多个项目是最小的,函数返回第一个。这是符合其他sort-stability保留等工具 sorted(iterable, key=keyfunc)[0]
和 heapq.nsmallest(1, iterable, key=keyfunc)
.
在新的3.4版本:默认keyword-only论点。
next(
检索从迭代器通过调用它的下一个项目
方法。如果违约,它返回迭代器是否耗尽,否则 StopIteration
是提高。
object
返回一个新的无特色的对象。 object
是所有类的一个基地。它的方法是常见的Python类的所有实例。这个函数不接受任何参数。
请注意
object
没有一个
,所以你不能指定任意属性的一个实例 object
类。
oct(
整数转换为八进制数的字符串。结果是一个有效的Python表达式。如果x是Python int
对象,它必须定义一个
方法返回一个整数。
open(文件,模式= ' r ',缓冲= 1,编码=没有错误=没有换行符= None,closefd = True,
打开文件并返回一个对应的 文件对象。如果文件不能打开,一个 OSError
是提高。
文件是一个 就对象给路径名(绝对或相对于当前工作目录)的文件打开或整数包装文件的文件描述符。(如果一个文件描述符,它关闭时返回的I / O对象是关闭,除非closefd将 False
.)
模式是一个可选的字符串,指定了模式的文件打开。它默认为 'r'
这意味着在文本模式打开阅读。其他常见的值 'w'
写作(删除文件如果它已经存在), 'x'
为独家创建和 'a'
为附加(在某些Unix系统,意味着所有写附加到文件的末尾不管当前寻求位置)。在文本模式下,如果没有指定编码的编码使用平台的依赖: locale.getpreferredencoding(False)
被称为当前语言环境编码。(阅读和写作的原始字节使用二进制模式和编码未指明的离开。)可用的模式是:
字符
意义
'r'
开放阅读(默认)
'w'
开放的写作,首先删除文件
'x'
开放独家创造,失败如果文件已经存在
'a'
开放的写作,附加的文件如果它存在
'b'
二进制模式
't'
文本模式(默认)
'+'
打开磁盘文件更新(阅读和写作)
'U'
普遍的换行模式(弃用)
默认的模式是 'r'
(打开阅读文本,同义词 'rt'
)。对于二进制读写访问模式 'w+b'
打开,这样就为0字节的文件。 'r+b'
打开文件没有截断。
正如前面提到的, 概述,Python区分二进制和文本I / O。打开的文件(包括以二进制模式 'b'
模式参数)返回的内容 bytes
对象没有任何解码。在文本模式(默认,或者当 't'
包含在模式参数),返回文件的内容是 str
,字节被首先使用平台相关的编码或解码编码如果使用指定的。
请注意
Python不依赖于底层操作系统概念的文本文件,所有的处理是通过Python本身,因此独立于平台的。
缓冲是一个可选的整型用于设置缓冲政策。通过0关闭缓冲(只允许在二进制模式),1选择行缓冲(仅在文本模式下可用),和一个整数> 1表明固定大小的块的大小的字节缓冲区。当没有缓冲参数,默认缓冲策略工作如下:
二进制文件缓存在固定大小的块,缓冲区的大小是选择使用启发式试图确定底层设备的块大小和回落 io.DEFAULT_BUFFER_SIZE
。在许多系统中,缓冲区通常是4096或8192字节。
“互动”的文本文件(文件 isatty()
返回 True
)使用行缓冲。其他文本文件为二进制文件使用上述政策。
编码所使用的编码解码的名称或编码文件。这应该只用于文本模式。默认的编码是依赖于平台(不管 locale.getpreferredencoding()
返回),但任何 文本编码可以使用Python支持。看到 codecs
模块支持的编码列表。
错误是一个可选的字符串指定编码和解码错误是如何处理这种不能用于二进制模式。各种标准的错误处理程序(以下列出 错误处理程序),尽管任何错误处理名称已被注册 codecs.register_error()
也是有效的。标准的名称包括:
'strict'
提高一个 ValueError
如果有一个编码错误异常。的默认值 None
有同样的效果。
'ignore'
忽略错误。注意,忽略编码错误可能导致数据丢失。
'replace'
导致替换标记(如 '?'
)插入哪里有畸形的数据。
'surrogateescape'
将代表任何错误的字节在Unicode代码点私人使用面积从U + U + DCFF DC80。这些私人代码点就会转回时相同的字节 surrogateescape
错误处理程序写入数据时使用。这是有用的在一个未知的编码处理文件。
'xmlcharrefreplace'
只有当写入一个文件的支持。不支持的字符编码替换为适当的XML字符引用 &#nnn;
.
'backslashreplace'
通过Python的斜转义序列替换畸形数据。
'namereplace'
(也写作时仅支持)取代了不支持的字符 \N{...}
转义序列。
换行符控制 普遍的换行工作模式(它只适用于文本模式)。它可以 None
, ''
, '\n'
, '\r'
, '\r\n'
。它的工作原理如下:
阅读时的输入流,如果换行符 None
,环球换行模式启用。行输入可以结束 '\n'
, '\r'
,或 '\r\n'
,这些都是翻译成 '\n'
之前返回给调用者。如果它是 ''
通用换行模式启用,但结局都是返回给调用者翻译。如果有任何其他的法律价值观,输入行只是被给定字符串终止,和行结束返回给调用者未翻译。
当编写输出流,如果换行符 None
,任何 '\n'
写字符转换到系统默认行分隔符, os.linesep
。如果换行符 ''
或 '\n'
,没有翻译。如果任何其他法律价值换行, '\n'
字符是给定字符串翻译写的。
如果closefd False
和一个文件描述符,而不是一个文件名,底层文件描述符将保持关闭打开的文件。如果一个文件名closefd必须给出 True
(默认),否则,它会抛出一个错误。
可以使用一个定制刀通过一个可调用的。底层文件描述符的文件对象然后通过调用刀(文件、旗帜)。开瓶器必须返回一个打开的文件描述符(传递 os.open
比赛结果在功能上类似于传递 None
).
新创建的文件 non-inheritable.
下面的例子使用了 dir_fd参数的 os.open()
函数打开一个文件相对于给定目录:
importos>>> dir_fd=os.open('somedir',os.O_RDONLY)>>> defopener(path,flags):... returnos.open(path,flags,dir_fd=dir_fd)...>>> withopen('spamspam.txt','w',opener=opener)asf:... print('This will be written to somedir/spamspam.txt',file=f)...>>> os.close(dir_fd)# don't leak a file descriptor
的类型 文件对象返回的 open()
函数依赖于模式。当 open()
用来打开一个文件在一个文本模式('w'
, 'r'
, 'wt'
, 'rt'
等),它返回的一个子类 io.TextIOBase
(特别是 io.TextIOWrapper
)。当用于与缓冲以二进制方式打开一个文件,返回的类的一个子类 io.BufferedIOBase
。确切的阶级不同:在读取二进制模式下,它返回一个 io.BufferedReader
;在写二进制和附加二进制模式,它返回一个 io.BufferedWriter
以读/写模式,它返回一个io.BufferedRandom
。禁用缓冲时,原始流的一个子类 io.RawIOBase
, io.FileIO
,返回。
参见文件处理模块,如 fileinput
, io
( open()
声明), os
, os.path
, tempfile
, shutil
.
3.3版本的变化:刀参数了。
的 'x'
模式是补充道。
IOError
用于提高,现在的别名 OSError
.
FileExistsError
现在在独家提出如果文件打开吗
创建模式('x'
)已经存在。
3.4版本的变化:文件现在non-inheritable。
弃用自3.4版本,4.0版本将被删除:的 'U'
模式。
3.5版本的变化:如果系统调用中断和信号处理器不引发一个异常,该函数现在重试的系统调用,而不是一个 InterruptedError
异常(见
的 'namereplace'
添加错误处理程序。
3.6版本的变化:支持添加到接受对象实现 os.PathLike
.
在Windows上,打开一个控制台缓冲可能返回的一个子类 io.RawIOBase
除了 io.FileIO
.
ord(
给定一个字符串代表一个Unicode字符,返回一个整数代表字符的Unicode代码点。例如, ord('a')
返回整数 97
和 ord('€')
(欧元)的回报 8364
。这是的倒数 chr()
.
pow(x,
返回x到y;如果z,返回x y,z模(更有效率比计算 pow(x, y) % z
)。双参数形式 pow(x, y)
相当于使用权力操作符: x
.
一定数值类型的参数。混合操作数类型,强迫二进制算术运算符规则适用。为 int
操作数,结果有相同的类型作为操作数(胁迫)除非第二个参数是消极的;在这种情况下,所有参数转换为浮动,浮动的结果。例如, 10
返回 100
,但10**-2
返回 0.01
。如果第二个参数是负的,第三个参数必须省略���如果z,x和y必须是整数类型,和y必须是非负数。
print(
打印文本流文件对象,由9月,紧随其后的是结束。9月,结束,文件,如果存在,必须作为关键字参数。
像所有non-keyword参数转换为字符串 str()
和写入到流,由9月,紧随其后的是结束。9月和结束都必须是字符串;他们也可以 None
,这意味着使用默认值。如果没有对象, print()
只会写。
文件的参数必须是一个对象 write(string)
方法,如果它不存在或 None
, sys.stdout
就会被使用。因为印刷参数转换为文本字符串, print()
不能用于二进制模式文件对象。对于这些,使用 file.write(...)
代替。
是否输出缓冲通常是由文件,但是如果冲洗关键字参数是正确的,流强制刷新。
3.3版本的变化:添加刷新关键字参数。
返回一个财产属性。
fget函数获取一个属性的值。fset设置一个属性值是一个函数。fdel删除一个属性值是一个函数。和医生创建文档字符串属性。
一个典型的用途是定义一个属性管理 x
:
classC:def__init__(self):self._x=Nonedefgetx(self):returnself._xdefsetx(self,value):self._x=valuedefdelx(self):delself._xx=property(getx,setx,delx,"I'm the 'x' property.")
如果c是c的一个实例, c.x
将调用getter, c.x = value
将调用setter和 del c.x
删除人。
如果,医生将所以的财产属性。否则,房地产将复制fget docstring(如果它存在的话)。这使得它可以创建只读属性很容易使用 property()
作为一个 装饰:
:"""Get the current voltage."""returnself._voltage
的 @property
修饰符将 voltage()
方法为“getter”为一个只读属性相同的名称,它为电压设置有“获取当前电压”。
属性对象 getter
, setter
, deleter
方法使用修饰符创建一份财产与相应的访问器功能设置为装饰功能。这是用一个例子做了最好的解释:
:"""I'm the 'x' property."""returnself._x@x.setterdefx(self,value):self._x=value@x.deleterdefx(self):delself._x
这段代码是完全等价的第一个例子。一定要给额外的函数名称相同的原始属性(x
在这种情况下)。
返回的属性对象也有属性 fget
, fset
, fdel
相应的构造函数参数。
3.5版本的变化:现在可写属性的文档字符串对象。
range(
range
(开始,
而不是一个函数, range
实际上是一个不可变的序列类型,记录在吗 范围和 序列类型——列表、元组、范围.
repr(
返回一个字符串包含一个可打印的代表一个对象。对于许多类型,这个函数使试图返回一个字符串,将产生一个对象传递给时相同的值 eval()
,否则表示是用尖括号括起来的字符串,它包含的类型对象的名称加上额外的信息通常包括对象的名称和地址。一个类可以控制通过定义这个函数返回的实例
方法。
reversed(
返回一个反向 迭代器。seq必须有一个对象
方法或支持的协议序列(
方法和
方法用整数参数开始 0
).
round(
返回浮点值的数字四舍五入小数点后ndigits位数。如果省略ndigits或 None
,它返回最近的整数输入。代表 number.
.
内置类型支持 round()
、价值观四舍五入为最接近的倍数10次方- ndigits;如果两个同样倍数接近,甚至舍入完成向的选择(例如,两个 round(0.5)
和 round(-0.5)
是 0
, round(1.5)
是 2
)。返回值是一个整数,如果调用了一个参数,否则相同类型的数量。
请注意
的行为 round()
花车可以令人惊讶:例如, round(2.675, 2)
给了 2.67
而不是预期的 2.68
。这不是一个错误:这是一个事实,大多数的结果小数分数不能完全表示为一个浮点数。看到 浮点运算:问题和局限性为更多的信息。
返回一个新的 set
对象,可选元素取自iterable。 set
是一个内置的类。看到 set
和 类型——集合,frozenset关于这个类的文档。
对于其他容器内置 frozenset
, list
, tuple
, dict
类,以及 collections
模块。
setattr(对象,名字,
这是相对应的 getattr()
。参数是一个对象,一个字符串和一个任意值。字符串可能现有的属性或一个新属性名称。函数分配价值属性,提供了对象允许它。例如, setattr(x, 'foobar', 123)
相当于 x.foobar = 123
.
(开始,
返回一个 片对象代表指定的一系列指标 range(start, stop, step)
。参数默认的启动和步骤 None
。片有只读数据属性的对象 start
, stop
和 step
这仅仅是返回的参数值(或违约)。他们没有其他明确的功能,但是它们使用Numerical Python和其他第三方扩展。部分对象也使用时生成扩展索引的语法。例如: a[start:stop:step]
或 a[start:stop, i]
。看到 itertools.islice()
返回一个迭代器的另一个版本。
sorted(
返回一个新的iterable项目的有序列表。
有两个可选参数必须指定为关键字参数。
键指定一个参数的函数,用于提取比较主要从每个列表元素: key=str.lower
。默认值是 None
(比较直接的元素)。
相反的是一个布尔值。如果设置为 True
,那么列表元素排序好像每个比较逆转。
使用 functools.cmp_to_key()
一个老式的cmp函数转换为一个关键功能。
内置的 sorted()
功能是保证稳定。排序是稳定的,如果保证不改变元素的相对顺序比较平等——这有助于排序在多个传递(例如,由部门,然后由工资等级)。
用于排序的例子和一个简短的排序教程,看看 排序如何.
staticmethod(
函数返回一个静态方法。
静态方法不能得到一个隐式的第一个参数。要声明一个静态方法,使用这个成语:
classC:@staticmethoddeff(arg1,arg2,...):...
的 @staticmethod
表单是一个函数 装饰——看到函数定义的描述 函数定义获取详细信息。
它可以被称为类(如 C.f()
(比如)或在一个实例 C().f()
)。除了它的类实例被忽略。
静态方法在Python中发现类似Java或c++。也看到 classmethod()
为创建有用的变体替代类构造函数。
有关静态方法的更多信息,请参考文档标准类型层次结构 标准的类型层次结构.
(对象= b”,编码=“utf - 8”,
返回一个 str
版本的对象。看到 str()
获取详细信息。
str
是内置的字符串 类。对于一般信息字符串,明白了 文本序列类型- str.
sum(
资金开始和iterable从左到右的物品并返回。开始违约 0
。iterable的项目通常是数字,开始值不能是一个字符串。
对于一些用例,有很好的替代品 sum()
。的首选,快速连接字符串序列的方法是通过调用 ''.join(sequence)
。添加和扩展精度浮点值,明白了 math.fsum()
。连接一系列iterable,考虑使用 itertools.chain()
.
super([
方法调用返回一个代理对象,代表父母或兄弟姐妹的类型。这是非常有用的用于访问被覆盖在一个类继承的方法。使用的搜索顺序是一样的 getattr()
除了类型本身是跳过。
的
属性的类型列表使用的方法解析搜索顺序 getattr()
和 super()
。属性是动态的,可以改变,无论何时更新继承层次结构。
如果省略第二个参数,返回超级对象是不受约束的。如果第二个参数是一个对象, isinstance(obj, type)
必须是真实的。如果第二个参数是一个类型, issubclass(type2, type)
必须是真实的(这是有用的类方法)。
有两个超级的典型用例。与单继承一个类层次结构,可以使用超级引用父类没有明确命名它们,从而使代码更易于维护。这个用密切的相似之处在其他编程语言中使用的。
第二个用例是支持合作动态执行环境中多重继承。这个用例是独一无二的,没有找到Python和静态编译语言或语言只支持单继承的。这使得它可以实现“钻石图”,多个基类实现相同的方法。好的设计要求,该方法具有相同的调用签名在任何情况下(因为在运行时调用的顺序决定,因为为了适应类层次结构的变化,因为这个顺序可以包括兄弟姐妹类运行时)之前是未知的。
对于这两个用例,一个典型的超类是这样的:
classC(B):defmethod(self,arg):super().method(arg)# This does the same thing as:# super(C, self).method(arg)
请注意, super()
被实现为绑定过程的一部分等明确的虚线属性查找 super().
。它通过实现自己
搜索类的方法预测订单,支持合作多重继承。因此, super()
是隐式定义查找使用语句或运营商如 super()[name]
.
还要注意,除了零参数形式, super()
并不局限于使用内部的方法。这两个论点形式指定参数准确,使适当的引用。零参数形式只能在类的内部定义,编译器填写必要的细节正确检索被定义的类,以及访问当前实例的普通方法。
实际的建议关于如何设计合作类使用 super()
,请参阅指南使用super().
tuple([
而不是一个函数, tuple
实际上是一个不可变的序列类型,记录在吗 元组和 序列类型——列表、元组、范围.
一个参数,返回一个对象的类型。返回值是一个对象类型和通常返回的对象一样 object.
.
的 isinstance()
内置函数建议测试一个对象的类型,因为它考虑了子类。
有三个参数,返回一个新的类型对象。这本质上是一个动态的形式 class
声明。这个名字是类名,成为字符串
元组属性;基地列举了基类,变成了
属性;关键字词典是包含类定义的名称空间的身体和复制到成为一个标准的字典
属性。例如,以下两个语句创建相同的 type
对象:
classX:... a=1...>>> X=type('X',(object,),dict(a=1))
另请参阅 类型的对象.
3.6版本的变化:的子类 type
不覆盖 type.
可能不再使用一个参数形式来获得一个对象的类型。
vars([
返回
属性模块、类实例,或任何其他对象
属性。
对象模块和实例等可更新
属性;但是,其他对象可能会限制他们的写
属性(例如,使用一个类 types.MappingProxyType
为了防止直接字典更新)。
没有一个论点, vars()
就像 locals()
。注意,当地人字典只用于读取以来更新当地人字典被忽略。
zip(** iterable
做一个集合元素的迭代器从每个iterable。
返回一个迭代器的元组,其中的第i个tuple包含每个参数序列的第i个元素或iterable。输入迭代器停止时最短iterable耗尽。用一个iterable论点,它返回一个迭代器1-tuples。不带参数,它将返回一个空的迭代器。等价于:
defzip(iterables):# zip('ABCD', 'xy') --> Ax Bysentinel=object()iterators=[iter(it)foritiniterables]whileiterators:result=[]foritiniterators:elem=next(it,sentinel)ifelemissentinel:returnresult.append(elem)yieldtuple(result)
的评价从左到右顺序iterable保证。这使可能的成语集群数据系列分为n-length组使用 zip(
。这种重复相同的迭代器 n
次,这样每个输出元组的结果 n
调用迭代器。这样做的效果是将输入分成n-length块。
zip()
只能使用不平等的长度输入当你不关心的,无与伦比的值不再iterable。如果这些值很重要,使用 itertools.zip_longest()
代替。
zip()
会同 *
操作符可以用来解压缩一个列表:
x=[1,2,3]>>> y=[4,5,6]>>> zipped=zip(x,y)>>> list(zipped)[(1, 4), (2, 5), (3, 6)]>>> x2,y2=zip(*zip(x,y))>>> x==list(x2)andy==list(y2)True
请注意
这是一个先进的功能,不需要在每天的Python编程,不像 importlib.import_module()
.
这个函数被调用的 import
声明。它可以(通过进口替代 builtins
模块和分配 builtins.
为了改变语义的 import
声明,但不提倡这样做,因为它通常是更简单的使用进口挂钩(见
也不赞成吗 importlib.import_module()
.
导入功能模块名称,可能使用给定的全局和当地人来决定如何解释这个名字在包上下文。fromlist给的名字应该进口的对象或子模块的名字。标准实现不使用它的当地人参数,并使用它的全局唯一确定的包上下文 import
声明。
指定是否使用绝对或相对进口水平。 0
(默认)意味着只有执行绝对进口。积极的水平值显示的数量相对于目录的父目录搜索模块调用
(见
当表单的变量的名称 package.module
,正常情况下,顶层包(这个名字到第一个点)返回,而不是模块的名字命名。然而,当一个非空fromlist参数,返回模块命名的名字。
例如,语句 import spam
结果在字节码类似下面的代码:
spam=('spam',globals(),locals(),[],0)
该声明 import spam.ham
这个调用的结果:
spam=('spam.ham',globals(),locals(),[],0)
请注意
返回顶层的模块,因为这是由对象绑定到一个名称 import
声明。
另一方面,这一声明 from spam.ham import eggs, sausage as saus
结果
_temp=('spam.ham',globals(),locals(),['eggs','sausage'],0)eggs=_temp.eggssaus=_temp.sausage
在这里, spam.ham
模块是回来
。从这个对象中,导入名称检索并分配给各自的名字。
如果你只是想要导入一个模块(可能在一个包)的名字,使用 importlib.import_module()
.
3.3版本的变化:负值为水平不再支持(也改变默认值为0)。
脚注
[1]
注意,解析器只接受线公约的unix形式结束。如果你正在阅读的代码文件,确保使用换行符转换模式将Windows或苹果样式换行。